// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'word_to_sl_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$WordToSlState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loaded,
    TResult? Function(String word, String letter, int i)? wordloaded,
    TResult? Function(String? error, int? code)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WordToSlInitial value)? initial,
    TResult? Function(WordToSlLoaded value)? loaded,
    TResult? Function(WordToSlWordLoaded value)? wordloaded,
    TResult? Function(WordToSlError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WordToSlStateCopyWith<$Res> {
  factory $WordToSlStateCopyWith(
          WordToSlState value, $Res Function(WordToSlState) then) =
      _$WordToSlStateCopyWithImpl<$Res, WordToSlState>;
}

/// @nodoc
class _$WordToSlStateCopyWithImpl<$Res, $Val extends WordToSlState>
    implements $WordToSlStateCopyWith<$Res> {
  _$WordToSlStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WordToSlInitialImplCopyWith<$Res> {
  factory _$$WordToSlInitialImplCopyWith(_$WordToSlInitialImpl value,
          $Res Function(_$WordToSlInitialImpl) then) =
      __$$WordToSlInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WordToSlInitialImplCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res, _$WordToSlInitialImpl>
    implements _$$WordToSlInitialImplCopyWith<$Res> {
  __$$WordToSlInitialImplCopyWithImpl(
      _$WordToSlInitialImpl _value, $Res Function(_$WordToSlInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WordToSlInitialImpl implements WordToSlInitial {
  const _$WordToSlInitialImpl();

  @override
  String toString() {
    return 'WordToSlState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WordToSlInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loaded,
    TResult? Function(String word, String letter, int i)? wordloaded,
    TResult? Function(String? error, int? code)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WordToSlInitial value)? initial,
    TResult? Function(WordToSlLoaded value)? loaded,
    TResult? Function(WordToSlWordLoaded value)? wordloaded,
    TResult? Function(WordToSlError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class WordToSlInitial implements WordToSlState {
  const factory WordToSlInitial() = _$WordToSlInitialImpl;
}

/// @nodoc
abstract class _$$WordToSlLoadedImplCopyWith<$Res> {
  factory _$$WordToSlLoadedImplCopyWith(_$WordToSlLoadedImpl value,
          $Res Function(_$WordToSlLoadedImpl) then) =
      __$$WordToSlLoadedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WordToSlLoadedImplCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res, _$WordToSlLoadedImpl>
    implements _$$WordToSlLoadedImplCopyWith<$Res> {
  __$$WordToSlLoadedImplCopyWithImpl(
      _$WordToSlLoadedImpl _value, $Res Function(_$WordToSlLoadedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WordToSlLoadedImpl implements WordToSlLoaded {
  const _$WordToSlLoadedImpl();

  @override
  String toString() {
    return 'WordToSlState.loaded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WordToSlLoadedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loaded,
    TResult? Function(String word, String letter, int i)? wordloaded,
    TResult? Function(String? error, int? code)? error,
  }) {
    return loaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WordToSlInitial value)? initial,
    TResult? Function(WordToSlLoaded value)? loaded,
    TResult? Function(WordToSlWordLoaded value)? wordloaded,
    TResult? Function(WordToSlError value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class WordToSlLoaded implements WordToSlState {
  const factory WordToSlLoaded() = _$WordToSlLoadedImpl;
}

/// @nodoc
abstract class _$$WordToSlWordLoadedImplCopyWith<$Res> {
  factory _$$WordToSlWordLoadedImplCopyWith(_$WordToSlWordLoadedImpl value,
          $Res Function(_$WordToSlWordLoadedImpl) then) =
      __$$WordToSlWordLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String word, String letter, int i});
}

/// @nodoc
class __$$WordToSlWordLoadedImplCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res, _$WordToSlWordLoadedImpl>
    implements _$$WordToSlWordLoadedImplCopyWith<$Res> {
  __$$WordToSlWordLoadedImplCopyWithImpl(_$WordToSlWordLoadedImpl _value,
      $Res Function(_$WordToSlWordLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? word = null,
    Object? letter = null,
    Object? i = null,
  }) {
    return _then(_$WordToSlWordLoadedImpl(
      null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as String,
      null == letter
          ? _value.letter
          : letter // ignore: cast_nullable_to_non_nullable
              as String,
      null == i
          ? _value.i
          : i // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$WordToSlWordLoadedImpl implements WordToSlWordLoaded {
  const _$WordToSlWordLoadedImpl(this.word, this.letter, this.i);

  @override
  final String word;
  @override
  final String letter;
  @override
  final int i;

  @override
  String toString() {
    return 'WordToSlState.wordloaded(word: $word, letter: $letter, i: $i)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WordToSlWordLoadedImpl &&
            (identical(other.word, word) || other.word == word) &&
            (identical(other.letter, letter) || other.letter == letter) &&
            (identical(other.i, i) || other.i == i));
  }

  @override
  int get hashCode => Object.hash(runtimeType, word, letter, i);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WordToSlWordLoadedImplCopyWith<_$WordToSlWordLoadedImpl> get copyWith =>
      __$$WordToSlWordLoadedImplCopyWithImpl<_$WordToSlWordLoadedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return wordloaded(word, letter, i);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loaded,
    TResult? Function(String word, String letter, int i)? wordloaded,
    TResult? Function(String? error, int? code)? error,
  }) {
    return wordloaded?.call(word, letter, i);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (wordloaded != null) {
      return wordloaded(word, letter, i);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return wordloaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WordToSlInitial value)? initial,
    TResult? Function(WordToSlLoaded value)? loaded,
    TResult? Function(WordToSlWordLoaded value)? wordloaded,
    TResult? Function(WordToSlError value)? error,
  }) {
    return wordloaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (wordloaded != null) {
      return wordloaded(this);
    }
    return orElse();
  }
}

abstract class WordToSlWordLoaded implements WordToSlState {
  const factory WordToSlWordLoaded(
          final String word, final String letter, final int i) =
      _$WordToSlWordLoadedImpl;

  String get word;
  String get letter;
  int get i;
  @JsonKey(ignore: true)
  _$$WordToSlWordLoadedImplCopyWith<_$WordToSlWordLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WordToSlErrorImplCopyWith<$Res> {
  factory _$$WordToSlErrorImplCopyWith(
          _$WordToSlErrorImpl value, $Res Function(_$WordToSlErrorImpl) then) =
      __$$WordToSlErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? error, int? code});
}

/// @nodoc
class __$$WordToSlErrorImplCopyWithImpl<$Res>
    extends _$WordToSlStateCopyWithImpl<$Res, _$WordToSlErrorImpl>
    implements _$$WordToSlErrorImplCopyWith<$Res> {
  __$$WordToSlErrorImplCopyWithImpl(
      _$WordToSlErrorImpl _value, $Res Function(_$WordToSlErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? code = freezed,
  }) {
    return _then(_$WordToSlErrorImpl(
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$WordToSlErrorImpl implements WordToSlError {
  const _$WordToSlErrorImpl({this.error, this.code});

  @override
  final String? error;
  @override
  final int? code;

  @override
  String toString() {
    return 'WordToSlState.error(error: $error, code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WordToSlErrorImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.code, code) || other.code == code));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, code);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WordToSlErrorImplCopyWith<_$WordToSlErrorImpl> get copyWith =>
      __$$WordToSlErrorImplCopyWithImpl<_$WordToSlErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loaded,
    required TResult Function(String word, String letter, int i) wordloaded,
    required TResult Function(String? error, int? code) error,
  }) {
    return error(this.error, code);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loaded,
    TResult? Function(String word, String letter, int i)? wordloaded,
    TResult? Function(String? error, int? code)? error,
  }) {
    return error?.call(this.error, code);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loaded,
    TResult Function(String word, String letter, int i)? wordloaded,
    TResult Function(String? error, int? code)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, code);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WordToSlInitial value) initial,
    required TResult Function(WordToSlLoaded value) loaded,
    required TResult Function(WordToSlWordLoaded value) wordloaded,
    required TResult Function(WordToSlError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WordToSlInitial value)? initial,
    TResult? Function(WordToSlLoaded value)? loaded,
    TResult? Function(WordToSlWordLoaded value)? wordloaded,
    TResult? Function(WordToSlError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WordToSlInitial value)? initial,
    TResult Function(WordToSlLoaded value)? loaded,
    TResult Function(WordToSlWordLoaded value)? wordloaded,
    TResult Function(WordToSlError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class WordToSlError implements WordToSlState {
  const factory WordToSlError({final String? error, final int? code}) =
      _$WordToSlErrorImpl;

  String? get error;
  int? get code;
  @JsonKey(ignore: true)
  _$$WordToSlErrorImplCopyWith<_$WordToSlErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
